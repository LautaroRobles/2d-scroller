// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Input;
RWTexture2D<float4> Output;

float TargetHeight;
float K;
float D;
float Spread;
float MaxHeight;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int kernelSize = 3;
    float kernel[3][3] = {{1/4,1/2,1/4},
                          {1/2, 1 ,1/2},
                          {1/4,1/2,1/4}};
    int radius = 1;

    // Spring spread 
    for(int x = 0; x < kernelSize; x++) {
        for(int y = 0; y < kernelSize; y++) {
            float2 offset = float2(x - radius, y - radius);
            float2 texCoord = id.xy;

            float height = (Input[texCoord].r * 2 - 1) * MaxHeight;
            float velocity = (Input[texCoord].g * 2 - 1) * MaxHeight;

            float neighbourHeight = (Input[texCoord + offset].r * 2 - 1) * MaxHeight;
            float neighbourVelocity = (Input[texCoord + offset].g * 2 - 1) * MaxHeight;

            neighbourHeight += Spread * (height - neighbourHeight);
            neighbourVelocity += Spread * (height - neighbourHeight);

            Output[texCoord + offset] = float4((neighbourHeight * 0.5 + 0.5) * MaxHeight, (neighbourVelocity * 0.5 + 0.5) * MaxHeight, 0, 1);
        }
    }

    // Spring simulation
    float2 texCoord = id.xy;

    float height = (Input[texCoord].r * 2 - 1) * MaxHeight;
    float velocity = (Input[texCoord].g * 2 - 1) * MaxHeight;

    float diff = height - TargetHeight;
    float loss = -D * velocity;
    float acceleration = -K * diff + loss;

    height += velocity;
    velocity += acceleration;

    Output[texCoord] = float4((height * 0.5 + 0.5) * MaxHeight, (velocity * 0.5 + 0.5) * MaxHeight, 0, 1);
}
